# JAVA的三中锁机制:

## 一、偏向锁:

​		**持有偏向锁的线程第一次进入的时候需要加锁,当第二次进入的时候不需要加锁**,类似于看门大爷偷偷为你走后面,第一次来的时候需要通行证,之后就不需要通行证一样放你进来。

​		偏向锁运行的时候如果遇到抢占锁(优先级更高的锁),则偏向锁会被挂起。

## 二、CAS(comparent and swap)自旋锁:

​		Lock锁,属于CAS自旋锁,原理简化理解为在**一定时效内死循环对比,如果超时获取不了,就挂起(进入阻塞状态),进入重量级锁,等待线程唤醒自己**,因为没涉及到锁机制,也没涉及到操作系统干涉线程,可以在某种程度上避免cpu的上下文切换,从而相对于阻塞锁来讲性能损耗更小

​		优点:不再加锁,不再阻塞线程,通过CAS算法进行循环对比,提高程序的运行性能

​		但是如果CAS自旋锁过于多,竞争过于激烈,性能会下降

## 三、重量级锁(阻塞锁):

​		比较典型的是synchronized锁,锁哪哪串行,比如开了六个线程同时对一个公共变量+1,在执行synchronized锁住的内容的时候,会变成串行,所以在锁住后,需要加一定的延迟,等待所有从线程对公共变量操作完毕后,才是真正的执行结果

## 四、三种锁的对比:

​		**偏向锁(可重用锁)->轻量级锁(CAS自旋锁)->重量级锁(synchronized阻塞锁)**

## 五、死锁的概念:

​		两个线程,各自有一个对方需要的锁,谁也不主动释放,全部在挂起,谁都动不了

